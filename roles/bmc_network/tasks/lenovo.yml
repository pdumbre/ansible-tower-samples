---
# roles/system_vpd/tasks/main.yml
# Retrieves system mtm 

- name: Get Redfish system info
  community.general.redfish_info:
    category: Systems
    command: GetSystemInventory
    baseuri: "{{ bmc_ip }}"
    username: "{{ redfish_user }}"
    password: "{{ redfish_password }}"
    validate_certs: false
  register: rf_info
    
- name: Extract system identifiers
  ansible.builtin.set_fact:
    system_mtm: >-
      {{
        (
          rf_info.redfish_facts.system.entries
          | json_query('[].SKU')
          | select('defined')
          | list
          | first
          | default(
              rf_info.redfish_facts.system.entries
              | json_query('[].SubModel')
              | select('defined')
              | list
              | first
            )
        )[0:4] | upper
      }}

- debug:
    msg: "Detected system: {{ system_inventory.redfish_facts.system.SerialNumber | default('Unknown) }}"

- name: Create selection_properties map for conditional settings
  set_fact:
    selection_properties:
      mtm: "{{ system_mtm }}"
      serial: "{{ system_serial }}"
      uuid: "{{ system_uuid }}"

- name: Display system MTM
  debug:
    msg: "Configuring account security for MTM: {{ system_mtm }}"

- name: Get current network interface configuration using Redfish API
  uri:
    url: "{{ redfish_host }}/redfish/v1/Managers/1/EthernetInterfaces"
    method: GET
    user: "{{ redfish_user }}"
    password: "{{ redfish_password }}"
    validate_certs: no
    force_basic_auth: yes
    return_content: yes
    status_code: [200]
  register: current_network
  delegate_to: localhost

- name: Get the first network interface URL
  set_fact:
    network_interface_uri: "{{ current_network.json.Members[0]['@odata.id'] }}"
  when: current_network.json.Members | length > 0

- name: Get first network interface details
  uri:
    url: "{{ redfish_host }}{{ network_interface_uri }}"
    method: GET
    user: "{{ redfish_user }}"
    password: "{{ redfish_password }}"
    force_basic_auth: yes
    validate_certs: no
    return_content: yes
  register: network_interface_detail
  delegate_to: localhost
  when: network_interface_uri is defined
  
- name: Extract current network settings from Redfish response
  set_fact:
    current_mac: "{{ network_interface_detail.json.MACAddress | default('Not available') }}"
    current_ipv6_addresses: "{{ network_interface_detail.json.IPv6Addresses | default([]) }}"
    current_ipv6_addr: "{{ network_interface_detail.json.IPv6Addresses[0].Address | default('') }}"
    current_dhcp: "{{ network_interface_detail.json.DHCPv4.DHCPEnabled | default(false) }}"
    
- name: Display current network configuration
  debug:
    msg: 
      - "========================================="
      - "Current Network Configuration"
      - "========================================="
      - "MAC Address: {{ current_mac }}"
      - "IPv6 Address: {{ current_ipv6_addr if current_ipv6_addr else 'Not configured' }}"
      - "DHCP Enabled: {{ current_dhcp }}"
      - "========================================="

- name: Check if IPv6 needs update
  set_fact:
    ipv6_needs_update: "{{ ipv6_address is defined and current_ipv6_addr != ipv6_address }}"

- debug:
    msg:
      - "ipv6_address={{ ipv6_address }}"
      - "type={{ ipv6_address | type_debug }}"

- name: Configure IPv6 on IMM using Redfish API
  uri:
    url: "{{ redfish_host }}{{ network_interface_uri }}"
    method: PATCH
    user: "{{ redfish_user }}"
    password: "{{ redfish_password }}"
    validate_certs: no
    force_basic_auth: yes
    body_format: json
    body:
      IPv6StaticAddresses:
        - Address: "{{ ipv6_address }}"
          SubnetMask: "{{ ipv6_netmask | default('255.255.255.0') }}"
          Gateway: "{{ ipv6_gateway | default('') }}"
    status_code: [200, 202, 204]
  register: ipv6_config
  delegate_to: localhost
  when:
    - ipv6_address is defined
    - ipv6_needs_update | bool
  changed_when: ipv6_config.status in [200, 202, 204]

- name: IPv6 already configured
  debug:
    msg: "IPv6 address already set to {{ ipv6_address }} - no change needed"
  when:
    - ipv6_address is defined
    - not (ipv6_needs_update | bool)

- name: Determine if system is M6 compatible
  set_fact:
    is_m6_7x02: "{{ system_mtm.startswith('7X02') }}"
    is_m6_7d2x: "{{ system_mtm.startswith('7D2X') }}"
    is_m6_7d2v: "{{ system_mtm.startswith('7D2V') }}"
    is_m6_7d76: "{{ system_mtm.startswith('7D76') }}"
    is_m6_7d9r: "{{ system_mtm.startswith('7D9R') }}"
    is_m6_7d73: "{{ system_mtm.startswith('7D73') }}"
    is_sn550: "{{ system_mtm.startswith('7X16') }}"

- name: Set M6 configuration flag
  set_fact:
    is_m6_server: "{{ is_m6_7x02 or is_m6_7d2x or is_m6_7d2v or is_m6_7d76 or is_m6_7d9r or is_m6_7d73 }}"

- name: Get current account service configuration using Redfish module
  community.general.redfish_info:
    category: Accounts
    command: ListUsers
    baseuri: "{{ bmc_ip }}"
    username: "{{ redfish_user }}"
    password: "{{ redfish_password }}"
    timeout: 30
  register: current_accounts
  delegate_to: localhost
  ignore_errors: yes

- name: Display current account information
  debug:
    msg: "Current account service queried successfully"
  when: current_accounts is succeeded

# M6 Server Configuration (7X02, 7D2X, 7D2V, 7D76, 7D9R, 7D73)
# accseccfg -am local -lp 0 -pe 0 -pew 0 -pc on -pl 10 -ci 0 -lf 0 -chgnew off -rc 0

- name: Configure M6 account security via direct API (fallback)
  uri:
    url: "https://{{ bmc_ip }}/redfish/v1/AccountService"
    method: PATCH
    user: "{{ redfish_user }}"
    password: "{{ redfish_password }}"
    validate_certs: no
    force_basic_auth: yes
    body_format: json
    body:
      MinPasswordLength: 10
      Oem:
        Lenovo:
          PasswordChangeOnFirstAccess: false
          PasswordReuseCount: 0
          PasswordComplexityCheck: true
    status_code: [200, 202, 204]
  register: m6_account_config_api
  delegate_to: localhost
  when:
    - is_m6_server | bool
  changed_when: m6_account_config_api.status in [200, 202, 204]

- name: M6 account security configured
  debug:
    msg: "Account security configured for M6 server {{ system_mtm }}"
  when:
    - is_m6_server | bool
    - (m6_account_config_api is changed)

# SN550 Configuration (7X16)
# accseccfg -lp 0 -pe 0 -pew 0 -pc off -pl 8 -ci 0 -lf 0 -chgdft off -chgnew off -rc 0
- name: Configure account security for SN550 using Redfish command
  community.general.redfish_command:
    category: Accounts
    command: UpdateAccountServiceProperties
    baseuri: "{{ bmc_ip }}"
    username: "{{ redfish_user }}"
    password: "{{ redfish_password }}"
    timeout: 30
    account_properties:
      MinPasswordLength: 8        # -pl 8: password length
  register: sn550_account_config
  delegate_to: localhost
  when: is_sn550 | bool
  ignore_errors: yes

- name: Configure SN550 account security via direct API (fallback)
  uri:
    url: "https://{{ bmc_ip }}/redfish/v1/AccountService"
    method: PATCH
    user: "{{ redfish_user }}"
    password: "{{ redfish_password }}"
    validate_certs: no
    force_basic_auth: yes
    body_format: json
    body:
      MinPasswordLength: 8
      Oem:
        Lenovo:
          PasswordChangeOnFirstAccess: false
          PasswordChangeOnDefault: false
          PasswordReuseCount: 0
          PasswordComplexityCheck: false
    status_code: [200, 202, 204]
  register: sn550_account_config_api
  delegate_to: localhost
  when:
    - is_sn550 | bool
    - sn550_account_config is failed
  changed_when: sn550_account_config_api.status in [200, 202, 204]

- name: SN550 account security configured
  debug:
    msg: "Account security configured for SN550 {{ system_mtm }}"
  when:
    - is_sn550 | bool
    - (sn550_account_config is succeeded or sn550_account_config_api is changed)

- name: Skip configuration for non-M6 systems
  debug:
    msg: "System MTM {{ system_mtm }} is not an M6 server - skipping account security configuration"
  when:
    - not (is_m6_server | bool)
    - not (is_sn550 | bool)

- name: Display account security configuration summary
  debug:
    msg:
      - "========================================="
      - "Account Security Configuration Summary"
      - "========================================="
      - "System MTM: {{ system_mtm }}"
      - "Is M6 Server: {{ is_m6_server }}"
      - "Is SN550: {{ is_sn550 }}"
      - "Module Method: {{ 'Success' if (m6_account_config_api is succeeded or sn550_account_config is succeeded) else 'Used API Fallback' }}"
      - "========================================="

- name: Configure Ports
  uri:
    url: "https://{{ bmc_ip }}/redfish/v1/Managers/1/NetworkProtocol"
    method: PATCH
    user: "{{ redfish_user }}"
    password: "{{ redfish_password }}"
    validate_certs: no
    force_basic_auth: yes
    body_format: json
    body:
      SSH:
        ProtocolEnabled: true
        Port: 22
      HTTPS:
        ProtocolEnabled: true
        Port: 443
      HTTP:
        ProtocolEnabled: true
        Port: 80
      SNMP:
        ProtocolEnabled: true
        Port: 161
    status_code: [200, 202, 204]
  register: ports_config
  delegate_to: localhost

- name: Display port configuration status
  debug:
    msg: "Network services configured - SSH: Enabled, HTTPS: Enabled, HTTP: Disabled, SNMP: Enabled"  

- name: Get current power restore policy via raw
  ansible.builtin.raw: power -rp
  vars:
    ansible_connection: ssh
    ansible_user: "{{ redfish_user }}"
    ansible_password: "{{ redfish_password }}"
  register: current_power_policy

- name: Parse current power restore policy raw
  set_fact:
    current_policy: "{{ current_power_policy.stdout | regex_search('(alwayson|alwaysoff|restore)', ignorecase=True) | default('unknown') | lower }}"
  when: current_power_policy.rc == 0

- name: Display current power restore policy
  debug:
    msg:
      - "Current Power Restore Policy: {{ current_policy | default('Unable to retrieve') }}"
      - "CLI Output: {{ current_power_policy.stdout | default('No output') | trim }}"

- name: Set desired power restore policy variable
  set_fact:
    desired_policy: "{{ power_restore_policy | default('restore') | lower }}"

- name: Validate power restore policy value
  assert:
    that:
      - desired_policy in ['alwayson', 'alwaysoff', 'restore']
    fail_msg: "Invalid power restore policy: {{ desired_policy }}. Must be one of: alwayson, alwaysoff, restore"
    success_msg: "Power restore policy validated: {{ desired_policy }}"

- name: Check if policy needs update
  set_fact:
    policy_needs_update: "{{ current_policy | default('unknown') != desired_policy }}"

- name: Policy already configured
  debug:
    msg: "Power restore policy already set to '{{ desired_policy }}' - no change needed"
  when: not (policy_needs_update | bool)

- name: Configure power restore policy via SSH CLI
  ansible.builtin.raw: "power -rp {{ desired_policy }}"
  register: power_policy_result
  delegate_to: "{{ ansible_host }}"
  vars:
    ansible_connection: ssh
    ansible_user: "{{ redfish_user }}"
    ansible_password: "{{ redfish_password }}"
    ansible_ssh_common_args: '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'
  when: policy_needs_update | bool
  changed_when: "'ok' in power_policy_result.stdout | lower or power_policy_result.rc == 0"
  failed_when:
    - power_policy_result.rc != 0
    - "'ok' not in power_policy_result.stdout | lower"

- name: Display power restore policy configuration result
  debug:
    msg:
      - "========================================="
      - "Power Restore Policy Configuration"
      - "========================================="
      - "Previous Policy: {{ current_policy | default('unknown') }}"
      - "Desired Policy: {{ desired_policy }}"
      - "Update Needed: {{ policy_needs_update }}"
      - "Command: power -rp {{ desired_policy }}"
      - "Output: {{ power_policy_result.stdout | default('No change - already configured') | trim }}"
      - "Status: {{ 'Configured' if (policy_needs_update and power_policy_result is changed) else 'Already correct' }}"
      - "========================================="

- name: Verify power restore policy after configuration
  ansible.builtin.raw: "power -rp"
  register: verify_power_policy
  delegate_to: "{{ ansible_host }}"
  vars:
    ansible_connection: ssh
    ansible_user: "{{ redfish_user }}"
    ansible_password: "{{ redfish_password }}"
  changed_when: false
  failed_when: false
  when: policy_needs_update | bool

- name: Parse verified power restore policy
  set_fact:
    verified_policy: "{{ verify_power_policy.stdout | regex_search('(alwayson|alwaysoff|restore)', ignorecase=True) | default('unknown') | lower }}"
  when:
    - policy_needs_update | bool
    - verify_power_policy.rc == 0

- name: Display verification result
  debug:
    msg:
      - "Verification: Power restore policy is now set to '{{ verified_policy | default(desired_policy) }}'"
      - "CLI Output: {{ verify_power_policy.stdout | default('Not verified') | trim }}"
  when: policy_needs_update | bool

# Enable IPMI over LAN on IMM using Ansible Redfish module

- name: Get current network protocol configuration
  community.general.redfish_info:
    category: Manager
    command: GetManagerInventory
    baseuri: "{{ bmc_ip }}"
    username: "{{ redfish_user }}"
    password: "{{ redfish_password }}"
    timeout: 30
  register: current_protocols
  delegate_to: localhost

- name: Extract current IPMI status
  set_fact:
    current_ipmi_enabled: "{{ current_protocols.redfish_facts.manager.entries[0].NetworkProtocol.IPMI.ProtocolEnabled | default(false) }}"
    current_ipmi_port: "{{ current_protocols.redfish_facts.manager.entries[0].NetworkProtocol.IPMI.Port | default(623) }}"

- name: Check if IPMI needs to be enabled
  set_fact:
    ipmi_needs_update: "{{ not current_ipmi_enabled or current_ipmi_port != 623 }}"

- name: Display current IPMI status
  debug:
    msg: 
      - "IPMI over LAN current status: {{ 'Enabled' if current_ipmi_enabled else 'Disabled' }}"
      - "IPMI Port: {{ current_ipmi_port }}"
      - "Update needed: {{ ipmi_needs_update }}"

- name: Enable IPMI over LAN
  ansible.builtin.uri:
    url: "https://{{ bmc_ip }}/redfish/v1/Managers/1/NetworkProtocol"
    method: PATCH
    user: "{{ redfish_user }}"
    password: "{{ redfish_password }}"
    force_basic_auth: yes
    validate_certs: false
    headers:
      Content-Type: application/json
    body_format: json
    body:
      IPMI:
        ProtocolEnabled: true
        Port: 623
    status_code:
      - 200
      - 204
  delegate_to: localhost
  register: ipmi_config
  when: ipmi_needs_update | bool

- name: IPMI already enabled
  debug:
    msg: "IPMI over LAN already enabled on port 623 - no change needed"
  when: not (ipmi_needs_update | bool)

- name: Display IPMI configuration status
  debug:
    msg: "IPMI over LAN enabled on port 623"
  when: ipmi_config is changed

# Enable USB Ethernet for inband operations on IMM
# Equivalent to: imm.command("usbeth -en enabled")

- name: Enable USB Ethernet using Lenovo CLI (authoritative)
  ansible.builtin.raw: |
    usbeth -en enabled
  vars:
    ansible_connection: ssh
    ansible_user: "{{ redfish_user }}"
    ansible_password: "{{ redfish_password }}"
  register: usb_eth_result
  changed_when: "'Success' in usb_eth_result.stdout or usb_eth_result.rc == 0"
  failed_when: usb_eth_result.rc != 0

- name: Get current BIOS settings
  uri:
    url: "https://{{ bmc_ip }}/redfish/v1/Systems/1/Bios"
    method: GET
    user: "{{ redfish_user }}"
    password: "{{ redfish_password }}"
    validate_certs: no
    force_basic_auth: yes
    return_content: yes
    status_code: [200]
  register: current_bios
  delegate_to: localhost


# Configure Operating mode to Maximum Performance on IMM using SSH CLI

- name: Set operating mode variable
  set_fact:
    operating_mode: "{{ imm_operating_mode | default('Maximum Performance') }}"

- name: Display operating mode to be configured
  debug:
    msg: "Configuring operating mode to: {{ operating_mode }}"

- name: Set operating mode to Maximum Performance via ASU command
  ansible.builtin.raw: 'asu set OperatingModes.ChooseOperatingMode "{{ operating_mode }}"'
  register: operating_mode_result
  delegate_to: "{{ ansible_host }}"
  vars:
    ansible_connection: ssh
    ansible_user: "{{ redfish_user }}"
    ansible_password: "{{ redfish_password }}"
  changed_when: "'successfully' in operating_mode_result.stdout | lower or operating_mode_result.rc == 0"
  failed_when:
    - operating_mode_result.rc != 0
    - "'successfully' not in operating_mode_result.stdout | lower"

- name: Display operating mode configuration result
  debug:
    msg:
      - "========================================="
      - "Operating Mode Configuration"
      - "========================================="
      - "Mode Set: {{ operating_mode }}"
      - "Command: asu set OperatingModes.ChooseOperatingMode \"{{ operating_mode }}\""
      - "Output: {{ operating_mode_result.stdout | default('No output') | trim }}"
      - "Status: {{ 'Configured' if operating_mode_result is changed else 'Check output' }}"
      - "========================================="
      - "NOTE: Changes may require a system reboot to take effect"
      - "========================================="

- name: Include VPD info gathering
  ansible.builtin.include_tasks: get_vpd_info.yml

- name: Load performance settings configuration
  ansible.builtin.set_fact:
    perf_config: "{{ performance_asu_settings | default({}) }}"

- name: Filter applicable performance settings based on conditions
  ansible.builtin.set_fact:
    applicable_settings: "{{ perf_config | select_applicable_settings(selection_properties) }}"

- name: Debug applicable performance settings
  ansible.builtin.debug:
    msg: "Configuring Performance Settings: {{ applicable_settings }}"
  when: applicable_settings | length > 0

- name: Check if performance settings need to be applied
  ansible.builtin.set_fact:
    has_performance_settings: "{{ applicable_settings | length > 0 }}"
